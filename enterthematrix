#!/usr/bin/env python3
#./enterthematrix [BANDWIDTH] [TRAFFIC]

from sys import argv
from random import choice, random
from time import sleep
from asyncio import run
from curses import (
    wrapper,
    curs_set,
    use_default_colors,
    init_pair,
    color_pair,
    COLOR_GREEN,
)

DEFAULT_BANDWIDTH  = 4
DEFAULT_TRAFFIC    = 16
ANIMATION_INTERVAL = 0.025
FULLNESS           = 1
STICKINESS         = 0.64e-3
MAX_COLS           = 1920
EXIT_KEYS          = ('q', 'Q',)
SPACE              = chr(0x20)
HIGHLIGHT_COLOR    = 0
STANDARD_COLOR     = 1

class MatrixAnimation:
    def __init__(self, stdscr, bandwidth, traffic):
        self.stdscr = stdscr
        self.stdscr.nodelay(1)
        curs_set(0)
        use_default_colors()
        init_pair(STANDARD_COLOR, COLOR_GREEN, -1)

        self.bandwidth          = bandwidth
        self.traffic            = traffic
        self.animation_interval = ANIMATION_INTERVAL
        self.fullness           = FULLNESS
        self.stickiness         = STICKINESS
        self.max_cols           = max(MAX_COLS, self.num_cols)
        self.exit_keys          = EXIT_KEYS

        self.alphabet     = self.get_alphabet()
        self.char_streams = [ [] for _ in range(self.max_cols) ]
        self.num_streams  = 0
        self.use_async    = self.can_use_asyncio()

        if self.use_async:
            self.animation_interval *= 2
            run(self.run_async())
        else:
            self.run()

    def get_alphabet(self):
        k, num_katas  = 0xff66,   56
        a, num_alphas = ord('A'), 26
        n, num_nums   = ord('0'), 10

        return [
            *range(k, k + num_katas),
            *range(a, a + num_alphas),
            *range(n, n + num_nums),
        ]

    def can_use_asyncio(self):
        try:
            from asyncio import to_thread
        except ImportError:
            return False
        return True

    @property
    def num_rows(self):
        return self.stdscr.getmaxyx()[0]

    @property
    def num_cols(self):
        return self.stdscr.getmaxyx()[1]

    @property
    def max_streams(self):
        return int(self.num_cols * self.bandwidth * self.fullness)

    async def run_async(self):
        from asyncio import to_thread, sleep as async_sleep, gather
        key = None
        while key not in map(ord, self.exit_keys):
            next_frame = to_thread(self.next_frame)
            animation_interval = async_sleep(self.animation_interval)
            await gather(next_frame, animation_interval)
            self.stdscr.refresh()
            key = self.stdscr.getch()

    def run(self):
        key = None
        while key not in map(ord, self.exit_keys):
            self.next_frame()
            self.stdscr.refresh()
            sleep(self.animation_interval)
            key = self.stdscr.getch()

    def next_frame(self):
        self.add_streams()
        self.expand_streams()
        self.render_streams()
        self.reduce_streams()

    def add_streams(self):
        for _ in range(self.traffic):
            if self.num_streams < self.max_streams:
                self.add_stream()

    def add_stream(self):
        col = choice(range(self.num_cols))
        if len(self.char_streams[col]) < self.bandwidth:
            max_size = choice(range(1, self.num_rows + 1))
            stickiness = self.stickiness
            stream = CharStream(max_size, stickiness)
            self.char_streams[col].append(stream)
            self.num_streams += 1

    def expand_streams(self):
        for col_streams in self.char_streams:
            for stream in col_streams:
                self.expand_stream(stream)

    def expand_stream(self, stream):
        char = chr(choice(self.alphabet))
        stream.expand(char)

    def reduce_streams(self):
        for col, col_streams in enumerate(self.char_streams):
            for idx, stream in enumerate(col_streams):
                if stream.is_full:
                    is_reduced = self.reduce_stream(stream)
                    if is_reduced:
                        self.char_streams[col][idx] = None
                        self.num_streams -= 1
            self.remove_reduced_streams(col)

    def reduce_stream(self, stream):
        stream.reduce()
        return stream.is_reduced

    def remove_reduced_streams(self, col):
        idx = 0
        while idx < len(self.char_streams[col]):
            if self.char_streams[col][idx] is None:
                self.char_streams[col].pop(idx)
            else:
                idx += 1

    def render_streams(self):
        for col, col_streams in enumerate(self.char_streams):
            for stream in col_streams:
                self.render_stream(stream, col)

    def render_stream(self, stream, col):
        for idx in range(len(stream)):
            row = idx
            is_highlighted = stream.is_highlighted(idx)
            self.addch(row, col, stream[idx].val, is_highlighted)

    def addch(self, row, col, char, is_highlighted = False):
        if self.can_addch(row, col):
            color = HIGHLIGHT_COLOR if is_highlighted else STANDARD_COLOR
            self.stdscr.addch(row, col, char, color_pair(color))

    def can_addch(self, row, col):
        return row < self.num_rows - 1 and col < self.num_cols - 1

class CharStream:
    def __init__(self, max_size, stickiness):
        self.max_size = max_size
        self.stickiness = stickiness
        self.chars = []
        self.is_reducing = False
        self.is_reduced = False
        self.reduce_idx = 0

    def __len__(self):
        return len(self.chars)

    def __getitem__(self, idx):
        return self.chars[idx]

    @property
    def is_full(self):
        return len(self) >= self.max_size

    def expand(self, char):
        if not self.is_full:
            sticky = bool(random() <= self.stickiness)
            self.chars.append(Char(char, sticky))

    def reduce(self):
        self.is_reducing = True
        if self.reduce_idx >= len(self):
            self.is_reduced = True
            return
        if not self.chars[self.reduce_idx].sticky:
            self.chars[self.reduce_idx].val = SPACE
        self.reduce_idx += 1

    def is_highlighted(self, idx):
        return self[idx].sticky or \
            (self.is_reducing and idx == self.reduce_idx) or \
            (not self.is_reducing and idx >= (len(self) - 1))

class Char:
    def __init__(self, val, sticky):
        self.val = val
        self.sticky = sticky

if __name__ == '__main__':
    bandwidth = int(argv[1]) if len(argv) > 1 else DEFAULT_BANDWIDTH
    traffic = int(argv[2]) if len(argv) > 2 else DEFAULT_TRAFFIC
    wrapper(MatrixAnimation, bandwidth, traffic)
    exit(0)

