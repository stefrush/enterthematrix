#!/usr/bin/env python3

NAME        = 'enterthematrix'
DESCRIPTION = 'a classic matrix terminal animation using curses'
VERSION     = '2.1.0'

# DEFAULTS
DEBUG              = False
BANDWIDTH          = 2
THROUGHPUT         = 4
NEOS_INFLUENCE     = 0.004
ANIMATION_INTERVAL = 0.042
LIMITER            = 0
MAX_COLS           = 1280
EXIT_KEYS          = ('q', 'Q', chr(0x1b))
USE_ASYNC          = True
MIN_STREAM_SIZE    = 2
STREAM_SIZE_MULT   = 0.8
KEY_COMMANDS       = {
    'd': 'toggle_debug',
    'p': 'toggle_paused',
    's': 'trigger_step',
    'c': 'clear_screen',
    'b': 'increase_bandwidth',
    'B': 'decrease_bandwidth',
    't': 'increase_throughput',
    'T': 'decrease_throughput',
    'n': 'increase_neos_influence',
    'N': 'decrease_neos_influence',
    'a': 'increase_animation_interval',
    'A': 'decrease_animation_interval',
    'l': 'increase_limiter',
    'L': 'decrease_limiter',
}

from sys import argv
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
from collections import deque
from asyncio import run
from time import sleep
from random import choice, random
from math import log
from curses import (
    wrapper,
    curs_set,
    use_default_colors,
    init_pair,
    color_pair,
    COLOR_GREEN,
    A_BOLD,
)
PAIR_HIGHLIGHTED = 0
PAIR_NORMAL      = 1
SPACE            = chr(0x20)

class MatrixAnimation:
    def __init__(self, stdscr, **kwargs):
        self.stdscr = stdscr
        self.stdscr.nodelay(1)
        curs_set(0)
        use_default_colors()
        init_pair(PAIR_NORMAL, COLOR_GREEN, -1)
        self.pair_highlighted = color_pair(PAIR_HIGHLIGHTED) | A_BOLD
        self.pair_normal      = color_pair(PAIR_NORMAL)

        self.debug              = kwargs.get('debug', DEBUG)
        self.bandwidth          = kwargs.get('bandwidth', BANDWIDTH)
        self.throughput         = kwargs.get('throughput', THROUGHPUT)
        self.neos_influence     = kwargs.get('neos_influence', NEOS_INFLUENCE)
        self.animation_interval = kwargs.get('animation_interval', ANIMATION_INTERVAL)
        self.limiter            = kwargs.get('limiter', LIMITER)
        self.max_cols           = kwargs.get('max_cols', MAX_COLS)
        self.exit_keys          = kwargs.get('exit_keys', EXIT_KEYS)
        self.use_async          = kwargs.get('use_async', USE_ASYNC) and self.can_use_async()
        self.min_stream_size    = kwargs.get('min_stream_size', MIN_STREAM_SIZE)
        self.stream_size_mult   = kwargs.get('stream_size_mult', STREAM_SIZE_MULT)
        self.key_commands       = kwargs.get('key_commands', KEY_COMMANDS)

        self.bandwidth_increment          = 1
        self.throughput_increment         = 1
        self.neos_influence_increment     = 1e-3
        self.animation_interval_increment = 1e-3
        self.limiter_increment            = 1e-2

        self.bandwidth_range          = (0, float('inf'))
        self.throughput_range         = (0, float('inf'))
        self.neos_influence_range     = (0, 1)
        self.animation_interval_range = (0, float('inf'))
        self.limiter_range            = (0, 1)
        self.max_cols_range           = (1, float('inf'))
        self.min_stream_size_range    = (MIN_STREAM_SIZE, float('inf'))
        self.stream_size_mult_range   = (0, 1)

        self.cleanable_params = (
            'throughput',
            'bandwidth',
            'neos_influence',
            'limiter',
            'animation_interval',
            'max_cols',
            'min_stream_size',
            'stream_size_mult',
        )
        self.clean_params()

        self.char_streams = [ deque() for _ in range(self.max_cols) ]
        self.num_streams  = 0
        self.is_paused    = False
        self.is_stepping  = False

        if self.use_async:
            run(self.run_async())
        else:
            self.run()

    def clean_params(self):
        for param in self.cleanable_params:
            self.limit_param(param)
            self.round_param(param)

    def limit_param(self, param):
        param_val = getattr(self, param)
        param_min, param_max = getattr(self, f'{param}_range')
        if param_val < param_min:
            setattr(self, param, param_min)
        if param_val > param_max:
            setattr(self, param, param_max)

    def round_param(self, param):
        param_val = getattr(self, param)
        param_increment = getattr(self, f'{param}_increment', None)
        if param_increment is not None:
            param_precision = 0 if type(param_increment) is int else -int(log(param_increment, 10)) + 1
            rounded_param = round(param_val, param_precision) if param_precision > 0 else int(param_val)
            setattr(self, param, rounded_param)

    def can_use_async(self):
        try:
            from asyncio import to_thread
        except ImportError:
            return False
        return True

    @property
    def max_streams(self):
        return int(min(self.max_cols, self.num_cols) * self.bandwidth * (1 - self.limiter))

    @property
    def num_rows(self):
        return self.stdscr.getmaxyx()[0]

    @property
    def num_cols(self):
        return self.stdscr.getmaxyx()[1]

    async def run_async(self):
        from asyncio import to_thread, sleep as async_sleep, gather
        key = None
        while key not in map(ord, self.exit_keys):
            async_next_frame = to_thread(self.next_frame)
            async_animation_interval = async_sleep(self.animation_interval)
            await gather(async_next_frame, async_animation_interval)
            key = self.stdscr.getch()
            self.handle_keypress(key)

    def run(self):
        key = None
        while key not in map(ord, self.exit_keys):
            self.next_frame()
            sleep(self.animation_interval)
            key = self.stdscr.getch()
            self.handle_keypress(key)

    def next_frame(self):
        if self.is_paused and not self.is_stepping:
            return
        self.add_streams()
        self.step_streams()
        self.render_streams()
        self.remove_streams()
        if self.debug:
            self.render_debug_message()
        self.stdscr.refresh()

    def add_streams(self):
        for _ in range(self.throughput):
            if self.at_max_throughput():
                break
            col = choice(range(min(self.max_cols, self.num_cols)))
            if self.can_add_stream(col):
                self.add_stream(col)

    def at_max_throughput(self):
        return self.num_streams >= self.max_streams

    def can_add_stream(self, col):
        return len(self.char_streams[col]) < self.bandwidth

    def add_stream(self, col):
        size = self.get_next_stream_size()
        stream = CharStream(size)
        self.char_streams[col].append(stream)
        self.num_streams += 1

    def get_next_stream_size(self):
        size = choice(range(1, self.num_rows + 1))
        return int(size * self.stream_size_mult)

    def step_streams(self):
        for col_streams in self.char_streams:
            for stream in col_streams:
                stream.step()

    def render_streams(self):
        for col, col_streams in enumerate(self.char_streams):
            for stream in col_streams:
                self.render_stream(stream, col)

    def render_stream(self, stream, col):
        if self.can_render_tail(stream):
            self.render_tail(stream, col)
        if self.can_render_before_head(stream):
            self.render_before_head(stream, col)
        if self.can_render_head(stream):
            self.render_head(stream, col)

    def can_render_head(self, stream):
        return stream.head_row < self.num_rows

    def render_head(self, stream, col):
        is_influenced_by_neo = random() <= self.neos_influence
        char = stream.next_char(is_influenced_by_neo)
        self.addch(stream.head_row, col, char, True)

    def can_render_before_head(self, stream):
        return stream.head_row - 1 >= 0 and \
            stream.head_row - 1 < self.num_rows and \
            not stream.latest_is_influenced

    def render_before_head(self, stream, col):
        self.addch(stream.head_row - 1, col, stream.latest_char)

    def can_render_tail(self, stream):
        return stream.tail_row >= 0 and not stream.tail_is_influenced()

    def render_tail(self, stream, col):
        self.addch(stream.tail_row, col, SPACE)

    def addch(self, row, col, char, is_highlighted=False):
        if self.can_addch(row, col):
            color = self.pair_highlighted if is_highlighted else self.pair_normal
            self.stdscr.addch(row, col, char, color)

    def can_addch(self, row, col):
        return row < self.num_rows and col < self.num_cols - 1

    def remove_streams(self):
        for col_streams in self.char_streams:
            if self.should_remove_stream(col_streams):
                self.remove_oldest_stream(col_streams)

    def should_remove_stream(self, col_streams):
        return col_streams and col_streams[0].tail_row >= (self.num_rows - 1)

    def remove_oldest_stream(self, col_streams):
        col_streams.popleft()
        self.num_streams -= 1

    def render_debug_message(self):
        row = self.num_rows - 1
        for idx, char in enumerate(self.debug_message):
            col = idx
            self.addch(row, col, char, True)

    @property
    def debug_message(self):
        return ' | '.join((
            f'STR: {self.num_streams}/{self.max_streams}',
            f'DIM: {self.num_cols}x{self.num_rows}',
            f'B: {self.bandwidth}',
            f'T: {self.throughput}',
            f'N: {self.neos_influence}',
            f'A: {self.animation_interval}',
            f'L: {self.limiter}',
        ))

    def handle_keypress(self, key):
        if key < 0:
            return
        command = self.key_commands.get(chr(key))
        if command is not None:
            self.exec_key_command(command)
            self.clean_params()

    def exec_key_command(self, command):
        getattr(self, command)()

    def toggle_debug(self):
        self.debug = not self.debug

    def toggle_paused(self):
        self.is_paused = not self.is_paused

    def trigger_step(self):
        self.is_stepping = True
        self.next_frame()
        self.is_stepping = False

    def clear_screen(self):
        for col_streams in self.char_streams:
            while col_streams:
                self.remove_oldest_stream(col_streams)
        self.stdscr.clear()

    def increase_bandwidth(self):
        self.bandwidth += self.bandwidth_increment

    def decrease_bandwidth(self):
        self.bandwidth -= self.bandwidth_increment

    def increase_throughput(self):
        self.throughput += self.throughput_increment

    def decrease_throughput(self):
        self.throughput -= self.throughput_increment

    def increase_neos_influence(self):
        self.neos_influence += self.neos_influence_increment

    def decrease_neos_influence(self):
        self.neos_influence -= self.neos_influence_increment

    def increase_animation_interval(self):
        self.animation_interval += self.animation_interval_increment

    def decrease_animation_interval(self):
        self.animation_interval -= self.animation_interval_increment

    def increase_limiter(self):
        self.limiter += self.limiter_increment

    def decrease_limiter(self):
        self.limiter -= self.limiter_increment

FIRST_KATA,  NUM_KATAS  = 0xff66,   56
FIRST_ALPHA, NUM_ALPHAS = ord('A'), 26
FIRST_NUM,   NUM_NUMS   = ord('0'), 10
ALPHABET = ( # Cypher: "All I see is blonde, brunette, redhead..."
    *range(FIRST_KATA, FIRST_KATA + NUM_KATAS),
    *range(FIRST_ALPHA, FIRST_ALPHA + NUM_ALPHAS),
    *range(FIRST_NUM, FIRST_NUM + NUM_NUMS),
)

class CharStream:
    def __init__(self, size):
        self.size                 = size
        self.head_row             = -1
        self.tail_row             = self.head_row - self.size
        self.latest_char          = None
        self.latest_is_influenced = False
        self.influenced_chars     = {}

    def step(self):
        self.head_row += 1
        self.tail_row += 1

    def next_char(self, is_influenced_by_neo=False):
        if is_influenced_by_neo:
            self.influenced_chars[self.head_row] = True
        self.latest_is_influenced = is_influenced_by_neo
        self.latest_char = chr(choice(ALPHABET))
        return self.latest_char

    def tail_is_influenced(self):
        if self.tail_row in self.influenced_chars:
            del self.influenced_chars[self.tail_row]
            return True
        return False

def main():
    arg_parser = ArgumentParser(prog=NAME, description=DESCRIPTION, \
        formatter_class=ArgumentDefaultsHelpFormatter)

    arg_parser.add_argument('-v', '--version', \
        action='version', version=f'{NAME} v{VERSION}')

    arg_parser.add_argument('-c', '--commands', \
        help='show a list of key commands and exit', \
        action='store_true')

    arg_parser.add_argument('-d', '--debug', \
        help='show program runtime information during the animation', \
        action='store_true', default=DEBUG)

    arg_parser.add_argument('-b', '--bandwidth', \
        help='set the maximum number of character animation streams per text column [0-inf)', \
        type=int, metavar='INT', default=BANDWIDTH)

    arg_parser.add_argument('-t', '--throughput', \
        help='set the number of character animation streams to create per animation frame [0-inf)', \
        type=int, metavar='INT', default=THROUGHPUT)

    arg_parser.add_argument('-n', '--neos-influence', \
        help='follow the white rabbit [0-1]', \
        type=float, metavar='FLOAT', default=NEOS_INFLUENCE)

    arg_parser.add_argument('-a', '--animation-interval', \
        help='set the amount of time in seconds between animation frames [0-inf)', \
        type=float, metavar='FLOAT', default=ANIMATION_INTERVAL)

    arg_parser.add_argument('-l', '--limiter', \
        help='limit the maximum number of streams by a factor of the limiter value [0-1]', \
        type=float, metavar='FLOAT', default=LIMITER)

    arg_parser.add_argument('-m', '--max-cols', \
        help='set the maximum number of text columns to animate [1-inf)', \
        type=int, metavar='INT', default=MAX_COLS)

    arg_parser.add_argument('-e', '--exit-keys', \
        help='set the keys to initiate exit; should be a space separated list eg. "e E"', \
        nargs='+', metavar='KEY', default=EXIT_KEYS)

    arg_parser.add_argument('--use-async', \
        help='turn on async frame rendering in supported environments', \
        action='store_true', default=USE_ASYNC)

    arg_parser.add_argument('--no-use-async', \
        help='turn off async frame rendering in supported environments', \
        action='store_false', default=bool(not USE_ASYNC), dest='use_async')

    def print_commands():
        for key, command, in KEY_COMMANDS.items():
            print(f'{key} => {command}')

    kwargs = vars(arg_parser.parse_args(argv[1:]))

    if kwargs.get('commands'):
        print_commands()
    else:
        wrapper(MatrixAnimation, **kwargs)

if __name__ == '__main__':
    main()

