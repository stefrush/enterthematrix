#!/usr/bin/env python3

NAME        = 'enterthematrix'
DESCRIPTION = 'a classic matrix terminal animation using curses'
VERSION     = '1.0.0'

# DEFAULTS
BANDWIDTH          = 2
THROUGHPUT         = 4
NEOS_INFLUENCE     = 0.64e-2
ANIMATION_INTERVAL = 0.0425
LIMITER            = 0
MAX_COLS           = 1280
EXIT_KEYS          = ('q', 'Q', chr(0x1b))
USE_ASYNC          = True
DEBUG              = False
STREAM_SIZE_MULT   = 0.8

from sys import argv
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
from collections import deque
from random import choice, random
from time import sleep
from asyncio import run
from curses import (
    wrapper,
    curs_set,
    use_default_colors,
    init_pair,
    color_pair,
    COLOR_GREEN,
    A_BOLD,
)
PAIR_HIGHLIGHTED = 0
PAIR_NORMAL      = 1
SPACE            = chr(0x20)

class MatrixAnimation:
    def __init__(self, stdscr, **kwargs):
        self.stdscr = stdscr
        self.stdscr.nodelay(1)
        curs_set(0)
        use_default_colors()
        init_pair(PAIR_NORMAL, COLOR_GREEN, -1)
        self.pair_highlighted = color_pair(PAIR_HIGHLIGHTED) | A_BOLD
        self.pair_normal    = color_pair(PAIR_NORMAL)

        self.clean_kwargs(kwargs)

        self.bandwidth          = kwargs.get('bandwidth', BANDWIDTH)
        self.throughput         = kwargs.get('throughput', THROUGHPUT)
        self.neos_influence     = kwargs.get('neos_influence', NEOS_INFLUENCE)
        self.animation_interval = kwargs.get('animation_interval', ANIMATION_INTERVAL)
        self.limiter            = kwargs.get('limiter', LIMITER)
        self.max_cols           = kwargs.get('max_cols', MAX_COLS)
        self.exit_keys          = kwargs.get('exit_keys', EXIT_KEYS)
        self.use_async          = kwargs.get('use_async', USE_ASYNC) and self.can_use_async()
        self.debug              = kwargs.get('debug', DEBUG)
        self.stream_size_mult   = kwargs.get('stream_size_mult', STREAM_SIZE_MULT)

        self.char_streams = [ deque() for _ in range(self.max_cols) ]
        self.num_streams  = 0

        if self.use_async:
            run(self.run_async())
        else:
            self.run()

    def clean_kwargs(self, kwargs):
        bandwidth          = kwargs.get('bandwidth', 0)
        throughput         = kwargs.get('throughput', 0)
        animation_interval = kwargs.get('animation_interval', 0)
        limiter            = kwargs.get('limiter', 0)
        max_cols           = kwargs.get('max_cols', 1)
        stream_size_mult   = kwargs.get('stream_size_mult', 0)

        if bandwidth < 0:
            del kwargs['bandwidth']
        if throughput < 0:
            del kwargs['throughput']
        if animation_interval < 0:
            del kwargs['animation_interval']
        if limiter < 0 or limiter >= 1:
            del kwargs['limiter']
        if max_cols < 1:
            del kwargs['max_cols']
        if stream_size_mult < 0:
            del kwargs['stream_size_mult']

    def can_use_async(self):
        try:
            from asyncio import to_thread
        except ImportError:
            return False
        return True

    @property
    def max_streams(self):
        return int(min(self.max_cols, self.num_cols) * self.bandwidth * (1 - self.limiter))

    @property
    def num_rows(self):
        return self.stdscr.getmaxyx()[0]

    @property
    def num_cols(self):
        return self.stdscr.getmaxyx()[1]

    async def run_async(self):
        from asyncio import to_thread, sleep as async_sleep, gather
        key = None
        while key not in map(ord, self.exit_keys):
            async_next_frame = to_thread(self.next_frame)
            async_animation_interval = async_sleep(self.animation_interval)
            await gather(async_next_frame, async_animation_interval)
            key = self.stdscr.getch()

    def run(self):
        key = None
        while key not in map(ord, self.exit_keys):
            self.next_frame()
            sleep(self.animation_interval)
            key = self.stdscr.getch()

    def next_frame(self):
        self.add_streams()
        self.step_streams()
        self.render_streams()
        self.remove_streams()
        if self.debug:
            self.render_debug_message()
        self.stdscr.refresh()

    def add_streams(self):
        for _ in range(self.throughput):
            if self.at_max_throughput():
                break
            col = choice(range(min(self.max_cols, self.num_cols)))
            if self.can_add_stream(col):
                self.add_stream(col)

    def at_max_throughput(self):
        return self.num_streams >= self.max_streams

    def can_add_stream(self, col):
        return len(self.char_streams[col]) < self.bandwidth

    def add_stream(self, col):
        size = choice(range(1, self.num_rows + 1))
        size = int(size * self.stream_size_mult)
        stream = CharStream(size)
        self.char_streams[col].append(stream)
        self.num_streams += 1

    def step_streams(self):
        for col_streams in self.char_streams:
            for stream in col_streams:
                stream.step()

    def render_streams(self):
        for col, col_streams in enumerate(self.char_streams):
            for stream in col_streams:
                self.render_stream(stream, col)

    def render_stream(self, stream, col):
        if self.can_render_tail(stream):
            self.render_tail(stream, col)
        if self.can_render_before_head(stream):
            self.render_before_head(stream, col)
        if self.can_render_head(stream):
            self.render_head(stream, col)

    def can_render_head(self, stream):
        return stream.head_row < self.num_rows

    def render_head(self, stream, col):
        is_influenced_by_neo = random() <= self.neos_influence
        char = stream.next_char(is_influenced_by_neo)
        self.addch(stream.head_row, col, char, True)

    def can_render_before_head(self, stream):
        return stream.head_row - 1 >= 0 and \
            stream.head_row - 1 < self.num_rows and \
            not stream.latest_is_influenced

    def render_before_head(self, stream, col):
        self.addch(stream.head_row - 1, col, stream.latest_char)

    def can_render_tail(self, stream):
        return stream.tail_row >= 0 and not stream.tail_is_influenced()

    def render_tail(self, stream, col):
        self.addch(stream.tail_row, col, SPACE)

    def addch(self, row, col, char, is_highlighted=False):
        if self.can_addch(row, col):
            color = self.pair_highlighted if is_highlighted else self.pair_normal
            self.stdscr.addch(row, col, char, color)

    def can_addch(self, row, col):
        return row < self.num_rows and col < self.num_cols - 1

    def remove_streams(self):
        for col_streams in self.char_streams:
            if self.should_remove_stream(col_streams):
                self.remove_oldest_stream(col_streams)

    def should_remove_stream(self, col_streams):
        return col_streams and col_streams[0].tail_row >= (self.num_rows - 1)

    def remove_oldest_stream(self, col_streams):
        col_streams.popleft()
        self.num_streams -= 1

    def render_debug_message(self):
        row = self.num_rows - 1
        for idx, char in enumerate(self.debug_message):
            col = idx
            self.addch(row, col, char, True)

    @property
    def debug_message(self):
        return ' | '.join((
            f'STR: {self.num_streams} / {self.max_streams}',
            f'DIM: {self.num_cols} x {self.num_rows}',
            f'B: {self.bandwidth}',
            f'T: {self.throughput}',
            f'N: {self.neos_influence}',
            f'A: {self.animation_interval}',
            f'L: {self.limiter}',
        ))

FIRST_KATA,  NUM_KATAS  = 0xff66,   56
FIRST_ALPHA, NUM_ALPHAS = ord('A'), 26
FIRST_NUM,   NUM_NUMS   = ord('0'), 10
ALPHABET = (
    *range(FIRST_KATA, FIRST_KATA + NUM_KATAS),
    *range(FIRST_ALPHA, FIRST_ALPHA + NUM_ALPHAS),
    *range(FIRST_NUM, FIRST_NUM + NUM_NUMS),
)

class CharStream:
    def __init__(self, size):
        self.size                 = size
        self.head_row             = -1
        self.tail_row             = self.head_row - self.size
        self.latest_char          = None
        self.latest_is_influenced = False
        self.influenced_chars     = {}

    def step(self):
        self.head_row += 1
        self.tail_row += 1

    def next_char(self, is_influenced_by_neo=False):
        if is_influenced_by_neo:
            self.influenced_chars[self.head_row] = True
        self.latest_is_influenced = is_influenced_by_neo
        self.latest_char = chr(choice(ALPHABET))
        return self.latest_char

    def tail_is_influenced(self):
        if self.tail_row in self.influenced_chars:
            del self.influenced_chars[self.tail_row]
            return True
        return False

def main():
    arg_parser = ArgumentParser(prog=NAME, description=DESCRIPTION, \
        formatter_class=ArgumentDefaultsHelpFormatter)

    arg_parser.add_argument('-v', '--version', \
        action='version', version=f'{NAME} v{VERSION}')

    arg_parser.add_argument('-b', '--bandwidth', \
        help='set the maximum number of character animation streams per text column [0-inf)', \
        type=int, metavar='INT', default=BANDWIDTH)

    arg_parser.add_argument('-t', '--throughput', \
        help='set the number of character animation streams to create per animation frame [0-inf)', \
        type=int, metavar='INT', default=THROUGHPUT)

    arg_parser.add_argument('-n', '--neos-influence', \
        help='follow the white rabbit [0-1]', \
        type=float, metavar='FLOAT', default=NEOS_INFLUENCE, dest='neos_influence')

    arg_parser.add_argument('-a', '--animation-interval', \
        help='set the amount of time in seconds between animation frames [0-inf)', \
        type=float, metavar='FLOAT', default=ANIMATION_INTERVAL, dest='animation_interval')

    arg_parser.add_argument('-l', '--limiter', \
        help='limit the maximum number of streams by a factor of the limiter value [0-1)', \
        type=float, metavar='FLOAT', default=LIMITER)

    arg_parser.add_argument('-m', '--max-cols', \
        help='set the maximum number of text columns to animate [1-inf)', \
        type=int, metavar='INT', default=MAX_COLS, dest='max_cols')

    arg_parser.add_argument('-e', '--exit-keys', \
        help='set the keys to initiate exit; should be a space separated list eg. "e E"', \
        nargs='+', metavar='KEY', default=EXIT_KEYS, dest='exit_keys')

    arg_parser.add_argument('--use-async', \
        help='turn on async frame rendering in supported environments', \
        action='store_true', default=USE_ASYNC, dest='use_async')

    arg_parser.add_argument('--no-use-async', \
        help='turn off async frame rendering in supported environments', \
        action='store_false', default=bool(not USE_ASYNC), dest='use_async')

    arg_parser.add_argument('-d', '--debug', \
        help='show program runtime information during the animation', \
        action='store_true', default=DEBUG)

    kwargs = vars(arg_parser.parse_args(argv[1:]))
    wrapper(MatrixAnimation, **kwargs)
    exit(0)

if __name__ == '__main__':
    main()

