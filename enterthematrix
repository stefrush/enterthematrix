#!/usr/bin/env python3
from time import sleep
from random import choice
from curses import wrapper, use_default_colors

class CharStream:
    def __init__(self, max_size):
        self.max_size = max_size
        self.chars = []
        self.is_reduced = False
        self.space = chr(0x20)

    def expand(self, char):
        if not self.is_full:
            self.chars.append(char)

    def reduce(self):
        for idx, char in enumerate(self.chars):
            if char != self.space:
                self.chars[idx] = self.space
                break
            elif idx >= len(self) - 1:
                self.is_reduced = True

    @property
    def is_full(self):
        return len(self) >= self.max_size

    def __len__(self):
        return len(self.chars)

    def __getitem__(self, idx):
        return self.chars[idx]

class MatrixAnimation:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.stdscr.nodelay(1)
        use_default_colors()

        self.max_cols = 640
        self.animation_interval = 0.06
        self.acceleration = 10
        self.fullness = 1
        self.escape_char = 'q'

        self.alphabet = self.get_alphabet()
        self.char_streams = [ None ] * self.max_cols
        self.num_streams = 0

        self.run()

    def get_alphabet(self):
        k, num_katas  = 0xff66,   56
        a, num_alphas = ord('A'), 26
        n, num_nums   = ord('0'), 10

        return [
            *range(k, k + num_katas),
            *range(a, a + num_alphas),
            *range(n, n + num_nums),
        ]

    @property
    def num_rows(self):
        return self.stdscr.getmaxyx()[0]

    @property
    def num_cols(self):
        return self.stdscr.getmaxyx()[1]

    @property
    def max_streams(self):
        return int(self.num_cols * self.fullness)

    def run(self):
        self.stdscr.clear()
        key = None
        while key != ord(self.escape_char):
            self.next_frame()
            self.stdscr.refresh()
            key = self.stdscr.getch()
            sleep(self.animation_interval)

    def next_frame(self):
        self.add_streams()
        self.expand_streams()
        self.render_streams()
        self.reduce_streams()

    def add_streams(self):
        for _ in range(self.acceleration):
            self.add_stream()

    def add_stream(self):
        if self.num_streams < self.max_streams:
            stream_idx = choice(range(self.num_cols))
            if self.char_streams[stream_idx] is None:
                stream_max_size = choice(range(1, self.num_rows + 1))
                stream = CharStream(stream_max_size)
                self.char_streams[stream_idx] = stream
                self.num_streams += 1

    def expand_streams(self):
        for stream in self.char_streams:
            if stream is not None:
                self.expand_stream(stream)

    def expand_stream(self, stream):
        char = chr(choice(self.alphabet))
        stream.expand(char)

    def render_streams(self):
        for idx, stream in enumerate(self.char_streams):
            if stream is not None:
                col = idx
                self.render_stream(stream, col)

    def render_stream(self, stream, col):
        for idx in range(len(stream)):
            row = idx
            if self.can_addch(row, col):
                self.stdscr.addch(row, col, stream[idx])

    def reduce_streams(self):
        for idx, stream in enumerate(self.char_streams):
            if stream is not None and stream.is_full:
                self.reduce_stream(stream, idx)

    def reduce_stream(self, stream, stream_idx):
        stream.reduce()
        if stream.is_reduced:
            self.char_streams[stream_idx] = None
            self.num_streams -= 1

    def can_addch(self, row, col):
        return row < self.num_rows - 1 and col < self.num_cols - 1

if __name__ == '__main__':
    wrapper(MatrixAnimation)
    exit(0)

